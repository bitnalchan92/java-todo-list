# java-todo-list

## 코드리뷰의 목적과 원칙
### 목적
- 코드리뷰는 단순히 코드를 확인하는 과정이 아니라, 더 나은 코드와 해결 방법을 찾아가는 협력의 시간입니다.
- 피드백을 주고받으며 함께 성장하고 배우는 데 그 목적이 있습니다.

### 원칙
#### 1.단계별 진행
- 과제는 총 4단계로 구성되어 있으며, 각 단계는 코드리뷰를 통해 merge 된 이후에만 다음 단계로 넘어갈 수 있습니다.
- 코드리뷰는 더 나은 결과물을 위한 과정이니, 정성껏 확인하고 리뷰어와 소통하며 완성도를 높여 보세요.

#### 2. 읽기 쉬운 코드 작성
- 내가 작성한 코드는 "처음 읽는 사람도 쉽게 이해할 수 있을까?"라는 관점에서 점검해 보세요.
- 복잡한 부분은 간단한 주석이나 설명을 더해, 리뷰어가 코드의 의도를 쉽게 파악할 수 있도록 배려하세요.

#### 3. 작고 명확한 커밋
- 커밋은 하나의 기능이나 변경사항만 담도록 하고, 명확한 커밋 메시지를 작성하세요.
- 작은 단위로 커밋하면 리뷰가 훨씬 수월해집니다.

#### 4. 열린 마음으로 피드백 수용
- 피드백은 더 나은 코드를 작성하기 위한 제안입니다.
- 개선점을 열린 마음으로 받아들이고, 필요하면 논의하면서 최선의 방향을 찾아보세요.

#### 5. 코드리뷰 깃 플로우
- [링크](https://github.com/next-step/nextstep-docs/blob/master/codereview/README.md)

## 공통 프로그래밍 요구사항
- 프로그램이 예상치 못한 상황에서도 정상 동작하도록 입력값 검증과 데이터 상태 확인을 통해 예외를 처리합니다.
    - 사용자가 잘못된 입력을 하거나 데이터가 부족한 경우, 프로그램의 흐름을 방해하지 않도록 안내 메시지를 제공하여 사용자 경험을 배려합니다.
- 변수, 메소드, 클래스 이름은 코드의 역할과 목적이 드러나도록 명확하게 작성합니다.
    - 읽는 사람이 이름만 보고도 기능을 쉽게 이해할 수 있도록 신중하게 선택하며, 일관된 네이밍 규칙을 유지합니다.

## 1 단계
**기본적인 할 일 목록 애플리케이션 개발**

[요구사항]
1. 프로그램 옵션 및 종료
    - 프로그램을 실행하면 사용자에게 "옵션을 선택하세요: 1. 추가, 2. 삭제, 3. 조회, 4. 종료" 라는 메시지를 보여줍니다.
    - 사용자가 1, 2, 3, 4를 입력하여 해당 기능을 실행합니다.
    - 4를 입력하면 "프로그램을 종료합니다."라고 출력하고 프로그램을 종료합니다.
    - 사용자가 잘못된 값을 입력하면 "잘못된 입력입니다."라는 메시지를 출력 후, 다시 옵션을 선택하도록 합니다.

2. 할 일 추가
    - 사용자가 할 일을 입력하면, 해당 정보를 저장됩니다. 각 할 일은 자동으로 고유 번호(ID)를 받게 됩니다.
        - 이 번호는 1부터 시작하여 새로운 할 일이 추가될 때마다 순서대로 증가합니다.
    - 할 일을 추가하면 "할 일이 추가되었습니다. ID: [할 일의 고유 번호]" 를 출력합니다.

3. 할 일 삭제
    - 사용자는 삭제하고 싶은 할 일의 고유 번호(ID)를 입력합니다.
    - 해당 번호의 할 일이 존재하면, 해당 할 일을 삭제하고 "할 일이 삭제되었습니다. ID: [삭제된 할 일의 고유 번호]"를 출력합니다.
    - 입력한 번호에 해당하는 할 일이 없으면 "해당 ID의 할 일이 없습니다."라고 알립니다.

4. 할 일 조회
    - 사용자는 조회하고자 하는 할 일의 고유 번호(ID)를 입력합니다.
    - 해당 번호의 할 일이 존재하면, "할 일 ID: [조회된 할 일의 고유 번호] 내용: [할 일의 설명]"를 출력 합니다.
    - 입력한 번호에 해당하는 할 일이 없으면 "해당 ID의 할 일이 없습니다."를 출력합니다.

- 힌트
    - HashMap 자료구조를 활용합니다.



## 2 단계
- **클래스 분리**
    - 클래스를 분리하는 주된 이유는 코드의 응집성을 높이고 결합도를 낮추기 위함입니다.
    - 응집성이 높은 코드는 관련된 기능이 하나의 클래스 내에 모여 있어 유지보수가 쉽고, 결합도가 낮은 코드는 다른 부분의 변경이 이 클래스에 미치는 영향이 적어 다른 코드와의 의존성이 줄어듭니다.
    - 이렇게 함으로써 코드의 재사용성을 높이고, 각 부분을 독립적으로 개발하고 테스트할 수 있습니다.

- **Single Responsibility Principle (SRP)**
    - 객체지향 소프트웨어 설계의 SOLID 원칙 중 하나로, "하나의 클래스는 하나의 책임만을 가져야 한다"라고 정의됩니다. 이 원칙은 응집도와 결합도에 직접적인 영향을 미치며, 소프트웨어의 설계 품질을 향상시키는 데 핵심적인 역할을 합니다.
    - 유지보수성: 한 클래스가 하나의 책임만을 갖도록 설계하면, 그 책임에 대한 변경이 필요할 때 해당 클래스만 수정하면 됩니다. 이는 예상치 못한 부작용을 줄이고, 코드의 유지보수를 용이하게 합니다.
    - 이해 및 관리 용이성: 클래스가 단일 책임을 갖는다면, 그 클래스의 기능을 이해하고 관리하기가 훨씬 쉽습니다. 코드의 복잡성이 낮아지며, 새로운 개발자가 코드베이스에 적응하는 시간도 단축됩니다.
    - 테스트 용이성: 단일 책임을 가진 클래스는 테스트하기가 더 쉽습니다. 각 클래스가 명확한 목적을 가지고 있으므로, 그 목적에 맞는 테스트 케이스를 작성하고 실행하기가 간단해집니다.

[요구사항]
1. 할 일 완료 기능
    - 할 일이 추가될 때, 할 일 상태의 기본 값은 '[미완료]' 입니다.
    - 할 일 조회 시, 상태도 함께 표시됩니다.
    - 입력받은 ID의 할 일을 찾아 완료 상태로 변경합니다.

2. 아래 7 개의 클래스로 나누어서 구현합니다. (static 메소드 사용 X)
- Main 클래스
    - 프로그램의 시작점을 담당합니다.
    - 애플리케이션 실행을 위한 진입점 역할을 수행합니다.

- Todo 클래스
    - Todo 객체의 속성과 동작을 정의합니다.
    - 속성: 고유 ID, 설명, 완료 여부 등.
    - 동작: 각 Todo와 관련된 도메인 로직

- TodoRepository 클래스
    - Todo 데이터의 CRUD 작업을 처리합니다.
    - 데이터 저장, 검색, 수정, 삭제 등의 작업을 수행합니다.
    - 데이터 관리를 책임지는 역할을 합니다.

- TodoService 클래스
    - 비즈니스 로직을 구현합니다.
    - Todo 데이터 처리 과정에서 필요한 규칙과 로직을 실행합니다.
    - TodoRepository와 연동해 데이터 작업을 수행합니다.

- TodoController 클래스
    - InputView를 통해 사용자 입력을 받고, TodoService를 호출하여 데이터를 처리합니다.
    - 처리된 결과를 OutputView에 전달하여 사용자에게 표시합니다.

- InputView 클래스
    - 사용자와의 상호작용을 담당하며, 사용자 입력값 처리와 UI(메뉴 표시 등)를 포함합니다.
    - 사용자가 입력해야 할 내용을 명확히 전달하고, 필요한 데이터를 수집합니다.

- OutputView 클래스
    - 처리된 결과를 사용자에게 출력합니다.

## 3 단계
### 1. 추가 요구사항 구현
[요구사항]
1. 전체 할 일 목록 출력
    - 오늘로부터 이후 7일 이내에 마감되는 할 일만 출력합니다.
    - 마감일을 기준으로 오름차순 정렬합니다.
2. 할 일 마감일 설정
    - 사용자가 할 일을 추가할 때, 마감일을 입력할 수 있습니다.
    - 할 일 조회 시, 마감일도 함께 표시됩니다.
3. 키워드 검색 기능
    - 사용자로부터 키워드를 입력 받습니다.
    - 해당 키워드를 포함하는 할 일을 검색합니다.
        - 마감일을 기준으로 오름차순 정렬합니다.
        - 키워드가 포함된 할 일이 없을 경우, "검색 결과가 없습니다." 메시지를 출력합니다.
4. 향상된 출력 기능
    - 출력 시, 아래와 같은 포맷으로 출력합니다.
    - <img width="541" alt="image" src="https://github.com/user-attachments/assets/f3b5caab-def7-43d2-95c1-97458d9a19e7" />

- 힌트
    - 정렬 기능은 Collections.sort 메소드를 사용합니다.
    - 향상된 출력 기능은 String.format 메소드를 사용합니다.
    - 객체 출력 시, toString 메소드를 사용해보세요.
    - 여유가 된다면 Java 8 Stream 메소드를 사용해보세요.

### 2. 예외처리 구현
애플리케이션에서 발생할 수 있는 예외 처리를 중앙에서 관리하여, 코드의 일관성과 유지 관리의 용이성을 향상시킵니다.
이를 통해 코드에서 null 체크를 줄이고, 더 안전하고 깔끔한 방식으로 처리가 가능합니다.

1. 예외 처리
    - TodoController의 run() 메소드는 애플리케이션의 주 실행 포인트로, 여기에서 발생하는 모든 예외를 try-catch 블록으로 감싸서 처리합니다.

2. Optional 활용
    - null 체크 대신 Optional 객체를 활용하여 데이터의 존재 여부를 확인합니다.
    - Optional의 orElseThrow() 메소드를 사용하여, 값이 존재하지 않을 경우 적절한 예외를 던지도록 합니다.

## 4 단계

### 1. Repository 패턴 도입

Repository 패턴은 데이터 액세스 로직을 중심화하고 데이터 스토어에 대한 접근을 추상화하는 것 입니다. 이를 위해, Todo 데이터에 관련된 CRUD(Create, Read, Update, Delete) 연산들을 담당하는 Repository 인터페이스를 설계합니다.

1. **TodoRepository 인터페이스 및 구현체 작성**
    - `TodoRepository` 인터페이스를 정의하고, 이를 구현하는 클래스를 작성합니다.
        - 인터페이스 정의 시, 변경을 최소화 하기 위해 기존  정의된 메소드 이름을 그대로 적용합니다.
        - TodoRepository 클래스를 `MapTodoRepository`로 이름을 변경하고,  인터페이스 `TodoRepository`를 상속받습니다.

2. **데이터베이스 연결 및 데이터 처리**
    - MySQL에 연결하기 위한 설정을 합니다.
    - 데이터베이스에 연결하여 할 일 데이터를 저장하고 읽는 메소드를 Repository 인터페이스를 상속 받아 `MySQLTodoRepository` 를 구현합니다.
        - Jdbc 또는 MyBatis 사용

3. **저장소 전환의 유연성**
    - 애플리케이션 설정이나 실행 중에 `TodoRepository`의 구현체를 변경하면, 메모리 저장소와 데이터베이스 저장소 사이를 쉽게 전환할 수 있어야 합니다.
    - 예를 들어, 테스트 환경에서는 메모리 저장소를 사용하고, 실제 프로덕션 환경에서는 데이터베이스를 사용하는 등의 유연한 전환이 가능해야 합니다.

### 2. 의존성 주입(DI) 구현
각 클래스의 인스턴스화를 중앙에서 관리하여 생성자를 통해 필요한 의존성을 주입하여 클래스 간의 결합도를 낮춥니다. 이는 프로그램의 유지보수성 높이며, 유닛 테스트의 용이성을 높입니다.

1. Main 클래스에서 애플리케이션의 모든 주요 클래스(TodoRepository, TodoService, TodoController, InputView, OutputView)를 초기화합니다.
2. 초기화된 인스턴스를 생성자를 통해 서로 필요로 하는 컴포넌트에 주입합니다.
   예를 들어, TodoController는 생성자를 통해 TodoService 인스턴스를 받고, TodoService는 TodoRepository 인스턴스를 받습니다.

이렇게 함으로써 각 클래스는 필요한 의존성만을 명확히 알고 있으며, 의존성 관리는 Main 클래스에서 중앙집중적으로 이루어집니다.
